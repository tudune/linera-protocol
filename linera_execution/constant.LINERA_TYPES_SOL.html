<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `LINERA_TYPES_SOL` constant in crate `linera_execution`."><title>LINERA_TYPES_SOL in linera_execution - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="linera_execution" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0 (05f9846f8 2025-03-31)" data-channel="1.86.0" data-search-js="search-581efc7a.js" data-settings-js="settings-6dad6058.js" ><script src="../static.files/storage-3a5871a4.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-4d63596a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc constant"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../linera_execution/index.html">linera_<wbr>execution</a><span class="version">0.15.0</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">linera_execution</a></div><h1>Constant <span class="constant">LINERA_TYPES_SOL</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/linera_execution/lib.rs.html#85">Source</a> </span></div><pre class="rust item-decl"><code>pub const LINERA_TYPES_SOL: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.86.0/std/primitive.str.html">str</a> = &quot;/// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nlibrary LineraTypes {\n\n    function bcs_serialize_len(uint256 x)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result;\n        bytes1 entry;\n        while (true) {\n            if (x &lt; 128) {\n                entry = bytes1(uint8(x));\n                result = abi.encodePacked(result, entry);\n                return result;\n            } else {\n                uint256 xb = x &gt;&gt; 7;\n                uint256 remainder = x - (xb &lt;&lt; 7);\n                require(remainder &lt; 128);\n                entry = bytes1(uint8(remainder) + 128);\n                result = abi.encodePacked(result, entry);\n                x = xb;\n            }\n        }\n        require(false, \&quot;This line is unreachable\&quot;);\n        return result;\n    }\n\n    function bcs_deserialize_offset_len(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, uint256)\n    {\n        uint256 idx = 0;\n        while (true) {\n            if (uint8(input[pos + idx]) &lt; 128) {\n                uint256 result = 0;\n                uint256 power = 1;\n                for (uint256 u=0; u&lt;idx; u++) {\n                    uint8 val = uint8(input[pos + u]) - 128;\n                    result += power * uint256(val);\n                    power *= 128;\n                }\n                result += power * uint8(input[pos + idx]);\n                uint256 new_pos = pos + idx + 1;\n                return (new_pos, result);\n            }\n            idx += 1;\n        }\n        require(false, \&quot;This line is unreachable\&quot;);\n        return (0,0);\n    }\n\n    struct TimeoutConfig {\n        opt_TimeDelta fast_round_duration;\n        TimeDelta base_timeout;\n        TimeDelta timeout_increment;\n        TimeDelta fallback_duration;\n    }\n\n    function bcs_serialize_TimeoutConfig(TimeoutConfig memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = bcs_serialize_opt_TimeDelta(input.fast_round_duration);\n        result = abi.encodePacked(result, bcs_serialize_TimeDelta(input.base_timeout));\n        result = abi.encodePacked(result, bcs_serialize_TimeDelta(input.timeout_increment));\n        result = abi.encodePacked(result, bcs_serialize_TimeDelta(input.fallback_duration));\n        return result;\n    }\n\n    function bcs_deserialize_offset_TimeoutConfig(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, TimeoutConfig memory)\n    {\n        uint256 new_pos = pos;\n        opt_TimeDelta memory fast_round_duration;\n        (new_pos, fast_round_duration) = bcs_deserialize_offset_opt_TimeDelta(new_pos, input);\n        TimeDelta memory base_timeout;\n        (new_pos, base_timeout) = bcs_deserialize_offset_TimeDelta(new_pos, input);\n        TimeDelta memory timeout_increment;\n        (new_pos, timeout_increment) = bcs_deserialize_offset_TimeDelta(new_pos, input);\n        TimeDelta memory fallback_duration;\n        (new_pos, fallback_duration) = bcs_deserialize_offset_TimeDelta(new_pos, input);\n        return (new_pos, TimeoutConfig(fast_round_duration, base_timeout, timeout_increment, fallback_duration));\n    }\n\n    function bcs_deserialize_TimeoutConfig(bytes memory input)\n        internal\n        pure\n        returns (TimeoutConfig memory)\n    {\n        uint256 new_pos;\n        TimeoutConfig memory value;\n        (new_pos, value) = bcs_deserialize_offset_TimeoutConfig(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    enum OptionBool { None, True, False }\n\n    function bcs_serialize_OptionBool(OptionBool input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        uint8 value0;\n        uint8 value1;\n        if (input == OptionBool.None) {\n            value0 = 0;\n            return abi.encodePacked(value0);\n        }\n        value0 = 1;\n        if (input == OptionBool.False) {\n            value1 = 0;\n            return abi.encodePacked(value0, value1);\n        }\n        value1 = 1;\n        return abi.encodePacked(value0, value1);\n    }\n\n    function bcs_deserialize_offset_OptionBool(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, OptionBool)\n    {\n        uint8 choice = uint8(input[pos]);\n        if (choice == 0) {\n           return (pos + 1, OptionBool.None);\n        } else {\n            require(choice == 1);\n            uint8 value = uint8(input[pos + 1]);\n            if (value == 0) {\n                return (pos + 2, OptionBool.False);\n            } else {\n                require(value == 1);\n                return (pos + 2, OptionBool.True);\n            }\n        }\n    }\n\n    function bcs_deserialize_OptionBool(bytes memory input)\n        internal\n        pure\n        returns (OptionBool)\n    {\n        uint256 new_pos;\n        OptionBool value;\n        (new_pos, value) = bcs_deserialize_offset_OptionBool(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct TimeDelta {\n        uint64 value;\n    }\n\n    function bcs_serialize_TimeDelta(TimeDelta memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = bcs_serialize_uint64(input.value);\n        return result;\n    }\n\n    function bcs_deserialize_offset_TimeDelta(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, TimeDelta memory)\n    {\n        uint256 new_pos = pos;\n        uint64 value;\n        (new_pos, value) = bcs_deserialize_offset_uint64(new_pos, input);\n        return (new_pos, TimeDelta(value));\n    }\n\n    function bcs_deserialize_TimeDelta(bytes memory input)\n        internal\n        pure\n        returns (TimeDelta memory)\n    {\n        uint256 new_pos;\n        TimeDelta memory value;\n        (new_pos, value) = bcs_deserialize_offset_TimeDelta(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct key_values_AccountOwner_uint64 {\n        AccountOwner key;\n        uint64 value;\n    }\n\n    function bcs_serialize_key_values_AccountOwner_uint64(key_values_AccountOwner_uint64 memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = bcs_serialize_AccountOwner(input.key);\n        result = abi.encodePacked(result, bcs_serialize_uint64(input.value));\n        return result;\n    }\n\n    function bcs_deserialize_offset_key_values_AccountOwner_uint64(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, key_values_AccountOwner_uint64 memory)\n    {\n        uint256 new_pos = pos;\n        AccountOwner memory key;\n        (new_pos, key) = bcs_deserialize_offset_AccountOwner(new_pos, input);\n        uint64 value;\n        (new_pos, value) = bcs_deserialize_offset_uint64(new_pos, input);\n        return (new_pos, key_values_AccountOwner_uint64(key, value));\n    }\n\n    function bcs_deserialize_key_values_AccountOwner_uint64(bytes memory input)\n        internal\n        pure\n        returns (key_values_AccountOwner_uint64 memory)\n    {\n        uint256 new_pos;\n        key_values_AccountOwner_uint64 memory value;\n        (new_pos, value) = bcs_deserialize_offset_key_values_AccountOwner_uint64(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    function bcs_serialize_uint32(uint32 input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = new bytes(4);\n        uint32 value = input;\n        result[0] = bytes1(uint8(value));\n        for (uint i=1; i&lt;4; i++) {\n            value = value &gt;&gt; 8;\n            result[i] = bytes1(uint8(value));\n        }\n        return result;\n    }\n\n    function bcs_deserialize_offset_uint32(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, uint32)\n    {\n        uint32 value = uint8(input[pos + 3]);\n        for (uint256 i=0; i&lt;3; i++) {\n            value = value &lt;&lt; 8;\n            value += uint8(input[pos + 2 - i]);\n        }\n        return (pos + 4, value);\n    }\n\n    function bcs_serialize_bool(bool input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(input);\n    }\n\n    function bcs_deserialize_offset_bool(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, bool)\n    {\n        uint8 val = uint8(input[pos]);\n        bool result = false;\n        if (val == 1) {\n            result = true;\n        } else {\n            require(val == 0);\n        }\n        return (pos + 1, result);\n    }\n\n    struct ChainOwnership {\n        AccountOwner[] super_owners;\n        key_values_AccountOwner_uint64[] owners;\n        uint32 multi_leader_rounds;\n        bool open_multi_leader_rounds;\n        TimeoutConfig timeout_config;\n    }\n\n    function bcs_serialize_ChainOwnership(ChainOwnership memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = bcs_serialize_seq_AccountOwner(input.super_owners);\n        result = abi.encodePacked(result, bcs_serialize_seq_key_values_AccountOwner_uint64(input.owners));\n        result = abi.encodePacked(result, bcs_serialize_uint32(input.multi_leader_rounds));\n        result = abi.encodePacked(result, bcs_serialize_bool(input.open_multi_leader_rounds));\n        result = abi.encodePacked(result, bcs_serialize_TimeoutConfig(input.timeout_config));\n        return result;\n    }\n\n    function bcs_deserialize_offset_ChainOwnership(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, ChainOwnership memory)\n    {\n        uint256 new_pos = pos;\n        AccountOwner[] memory super_owners;\n        (new_pos, super_owners) = bcs_deserialize_offset_seq_AccountOwner(new_pos, input);\n        key_values_AccountOwner_uint64[] memory owners;\n        (new_pos, owners) = bcs_deserialize_offset_seq_key_values_AccountOwner_uint64(new_pos, input);\n        uint32 multi_leader_rounds;\n        (new_pos, multi_leader_rounds) = bcs_deserialize_offset_uint32(new_pos, input);\n        bool open_multi_leader_rounds;\n        (new_pos, open_multi_leader_rounds) = bcs_deserialize_offset_bool(new_pos, input);\n        TimeoutConfig memory timeout_config;\n        (new_pos, timeout_config) = bcs_deserialize_offset_TimeoutConfig(new_pos, input);\n        return (new_pos, ChainOwnership(super_owners, owners, multi_leader_rounds, open_multi_leader_rounds, timeout_config));\n    }\n\n    function bcs_deserialize_ChainOwnership(bytes memory input)\n        internal\n        pure\n        returns (ChainOwnership memory)\n    {\n        uint256 new_pos;\n        ChainOwnership memory value;\n        (new_pos, value) = bcs_deserialize_offset_ChainOwnership(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct BlockHeight {\n        uint64 value;\n    }\n\n    function bcs_serialize_BlockHeight(BlockHeight memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = bcs_serialize_uint64(input.value);\n        return result;\n    }\n\n    function bcs_deserialize_offset_BlockHeight(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, BlockHeight memory)\n    {\n        uint256 new_pos = pos;\n        uint64 value;\n        (new_pos, value) = bcs_deserialize_offset_uint64(new_pos, input);\n        return (new_pos, BlockHeight(value));\n    }\n\n    function bcs_deserialize_BlockHeight(bytes memory input)\n        internal\n        pure\n        returns (BlockHeight memory)\n    {\n        uint256 new_pos;\n        BlockHeight memory value;\n        (new_pos, value) = bcs_deserialize_offset_BlockHeight(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct CryptoHash {\n        bytes32 value;\n    }\n\n    function bcs_serialize_CryptoHash(CryptoHash memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = bcs_serialize_bytes32(input.value);\n        return result;\n    }\n\n    function bcs_deserialize_offset_CryptoHash(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, CryptoHash memory)\n    {\n        uint256 new_pos = pos;\n        bytes32 value;\n        (new_pos, value) = bcs_deserialize_offset_bytes32(new_pos, input);\n        return (new_pos, CryptoHash(value));\n    }\n\n    function bcs_deserialize_CryptoHash(bytes memory input)\n        internal\n        pure\n        returns (CryptoHash memory)\n    {\n        uint256 new_pos;\n        CryptoHash memory value;\n        (new_pos, value) = bcs_deserialize_offset_CryptoHash(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct MessageIsBouncing {\n        OptionBool value;\n    }\n\n    function bcs_serialize_MessageIsBouncing(MessageIsBouncing memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = bcs_serialize_OptionBool(input.value);\n        return result;\n    }\n\n    function bcs_deserialize_offset_MessageIsBouncing(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, MessageIsBouncing memory)\n    {\n        uint256 new_pos = pos;\n        OptionBool value;\n        (new_pos, value) = bcs_deserialize_offset_OptionBool(new_pos, input);\n        return (new_pos, MessageIsBouncing(value));\n    }\n\n    function bcs_deserialize_MessageIsBouncing(bytes memory input)\n        internal\n        pure\n        returns (MessageIsBouncing memory)\n    {\n        uint256 new_pos;\n        MessageIsBouncing memory value;\n        (new_pos, value) = bcs_deserialize_offset_MessageIsBouncing(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    function bcs_serialize_bytes20(bytes20 input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(input);\n    }\n\n    function bcs_deserialize_offset_bytes20(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, bytes20)\n    {\n        bytes20 dest;\n        assembly {\n            dest := mload(add(add(input, 0x20), pos))\n        }\n        uint256 new_pos = pos + 20;\n        return (new_pos, dest);\n    }\n\n    struct opt_MessageId {\n        bool has_value;\n        MessageId value;\n    }\n\n    function bcs_serialize_opt_MessageId(opt_MessageId memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bool has_value = input.has_value;\n        bytes memory block1 = bcs_serialize_bool(has_value);\n        if (has_value) {\n            bytes memory block2 = bcs_serialize_MessageId(input.value);\n            return abi.encodePacked(block1, block2);\n        } else {\n            return block1;\n        }\n    }\n\n    function bcs_deserialize_offset_opt_MessageId(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, opt_MessageId memory)\n    {\n        uint256 new_pos;\n        bool has_value;\n        (new_pos, has_value) = bcs_deserialize_offset_bool(pos, input);\n        MessageId memory value;\n        if (has_value) {\n            (new_pos, value) = bcs_deserialize_offset_MessageId(new_pos, input);\n        }\n        return (new_pos, opt_MessageId(true, value));\n    }\n\n    function bcs_deserialize_opt_MessageId(bytes memory input)\n        internal\n        pure\n        returns (opt_MessageId memory)\n    {\n        uint256 new_pos;\n        opt_MessageId memory value;\n        (new_pos, value) = bcs_deserialize_offset_opt_MessageId(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    function bcs_serialize_uint64(uint64 input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = new bytes(8);\n        uint64 value = input;\n        result[0] = bytes1(uint8(value));\n        for (uint i=1; i&lt;8; i++) {\n            value = value &gt;&gt; 8;\n            result[i] = bytes1(uint8(value));\n        }\n        return result;\n    }\n\n    function bcs_deserialize_offset_uint64(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, uint64)\n    {\n        uint64 value = uint8(input[pos + 7]);\n        for (uint256 i=0; i&lt;7; i++) {\n            value = value &lt;&lt; 8;\n            value += uint8(input[pos + 6 - i]);\n        }\n        return (pos + 8, value);\n    }\n\n    function bcs_serialize_seq_AccountOwner(AccountOwner[] memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        uint256 len = input.length;\n        bytes memory result = bcs_serialize_len(len);\n        for (uint256 i=0; i&lt;len; i++) {\n            result = abi.encodePacked(result, bcs_serialize_AccountOwner(input[i]));\n        }\n        return result;\n    }\n\n    function bcs_deserialize_offset_seq_AccountOwner(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, AccountOwner[] memory)\n    {\n        uint256 len;\n        uint256 new_pos;\n        (new_pos, len) = bcs_deserialize_offset_len(pos, input);\n        AccountOwner[] memory result;\n        result = new AccountOwner[](len);\n        AccountOwner memory value;\n        for (uint256 i=0; i&lt;len; i++) {\n            (new_pos, value) = bcs_deserialize_offset_AccountOwner(new_pos, input);\n            result[i] = value;\n        }\n        return (new_pos, result);\n    }\n\n    function bcs_deserialize_seq_AccountOwner(bytes memory input)\n        internal\n        pure\n        returns (AccountOwner[] memory)\n    {\n        uint256 new_pos;\n        AccountOwner[] memory value;\n        (new_pos, value) = bcs_deserialize_offset_seq_AccountOwner(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct opt_TimeDelta {\n        bool has_value;\n        TimeDelta value;\n    }\n\n    function bcs_serialize_opt_TimeDelta(opt_TimeDelta memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bool has_value = input.has_value;\n        bytes memory block1 = bcs_serialize_bool(has_value);\n        if (has_value) {\n            bytes memory block2 = bcs_serialize_TimeDelta(input.value);\n            return abi.encodePacked(block1, block2);\n        } else {\n            return block1;\n        }\n    }\n\n    function bcs_deserialize_offset_opt_TimeDelta(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, opt_TimeDelta memory)\n    {\n        uint256 new_pos;\n        bool has_value;\n        (new_pos, has_value) = bcs_deserialize_offset_bool(pos, input);\n        TimeDelta memory value;\n        if (has_value) {\n            (new_pos, value) = bcs_deserialize_offset_TimeDelta(new_pos, input);\n        }\n        return (new_pos, opt_TimeDelta(true, value));\n    }\n\n    function bcs_deserialize_opt_TimeDelta(bytes memory input)\n        internal\n        pure\n        returns (opt_TimeDelta memory)\n    {\n        uint256 new_pos;\n        opt_TimeDelta memory value;\n        (new_pos, value) = bcs_deserialize_offset_opt_TimeDelta(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    function bcs_serialize_bytes32(bytes32 input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(input);\n    }\n\n    function bcs_deserialize_offset_bytes32(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, bytes32)\n    {\n        bytes32 dest;\n        assembly {\n            dest := mload(add(add(input, 0x20), pos))\n        }\n        uint256 new_pos = pos + 32;\n        return (new_pos, dest);\n    }\n\n    function bcs_serialize_seq_key_values_AccountOwner_uint64(key_values_AccountOwner_uint64[] memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        uint256 len = input.length;\n        bytes memory result = bcs_serialize_len(len);\n        for (uint256 i=0; i&lt;len; i++) {\n            result = abi.encodePacked(result, bcs_serialize_key_values_AccountOwner_uint64(input[i]));\n        }\n        return result;\n    }\n\n    function bcs_deserialize_offset_seq_key_values_AccountOwner_uint64(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, key_values_AccountOwner_uint64[] memory)\n    {\n        uint256 len;\n        uint256 new_pos;\n        (new_pos, len) = bcs_deserialize_offset_len(pos, input);\n        key_values_AccountOwner_uint64[] memory result;\n        result = new key_values_AccountOwner_uint64[](len);\n        key_values_AccountOwner_uint64 memory value;\n        for (uint256 i=0; i&lt;len; i++) {\n            (new_pos, value) = bcs_deserialize_offset_key_values_AccountOwner_uint64(new_pos, input);\n            result[i] = value;\n        }\n        return (new_pos, result);\n    }\n\n    function bcs_deserialize_seq_key_values_AccountOwner_uint64(bytes memory input)\n        internal\n        pure\n        returns (key_values_AccountOwner_uint64[] memory)\n    {\n        uint256 new_pos;\n        key_values_AccountOwner_uint64[] memory value;\n        (new_pos, value) = bcs_deserialize_offset_seq_key_values_AccountOwner_uint64(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n    struct AccountOwner {\n        uint8 choice;\n        // choice=0 corresponds to Reserved\n        uint8 reserved;\n        // choice=1 corresponds to Address32\n        CryptoHash address32;\n        // choice=2 corresponds to Address20\n        bytes20 address20;\n    }\n\n    function bcs_serialize_AccountOwner(AccountOwner memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = abi.encodePacked(input.choice);\n        if (input.choice == 0) {\n            return abi.encodePacked(result, bcs_serialize_uint8(input.reserved));\n        }\n        if (input.choice == 1) {\n            return abi.encodePacked(result, bcs_serialize_CryptoHash(input.address32));\n        }\n        if (input.choice == 2) {\n            return abi.encodePacked(result, bcs_serialize_bytes20(input.address20));\n        }\n        return result;\n    }\n\n    function bcs_deserialize_offset_AccountOwner(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, AccountOwner memory)\n    {\n        uint256 new_pos;\n        uint8 choice;\n        (new_pos, choice) = bcs_deserialize_offset_uint8(pos, input);\n        uint8 reserved;\n        if (choice == 0) {\n            (new_pos, reserved) = bcs_deserialize_offset_uint8(new_pos, input);\n        }\n        CryptoHash memory address32;\n        if (choice == 1) {\n            (new_pos, address32) = bcs_deserialize_offset_CryptoHash(new_pos, input);\n        }\n        bytes20 address20;\n        if (choice == 2) {\n            (new_pos, address20) = bcs_deserialize_offset_bytes20(new_pos, input);\n        }\n        return (new_pos, AccountOwner(choice, reserved, address32, address20));\n    }\n\n    function bcs_deserialize_AccountOwner(bytes memory input)\n        internal\n        pure\n        returns (AccountOwner memory)\n    {\n        uint256 new_pos;\n        AccountOwner memory value;\n        (new_pos, value) = bcs_deserialize_offset_AccountOwner(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct opt_uint32 {\n        bool has_value;\n        uint32 value;\n    }\n\n    function bcs_serialize_opt_uint32(opt_uint32 memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bool has_value = input.has_value;\n        bytes memory block1 = bcs_serialize_bool(has_value);\n        if (has_value) {\n            bytes memory block2 = bcs_serialize_uint32(input.value);\n            return abi.encodePacked(block1, block2);\n        } else {\n            return block1;\n        }\n    }\n\n    function bcs_deserialize_offset_opt_uint32(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, opt_uint32 memory)\n    {\n        uint256 new_pos;\n        bool has_value;\n        (new_pos, has_value) = bcs_deserialize_offset_bool(pos, input);\n        uint32 value;\n        if (has_value) {\n            (new_pos, value) = bcs_deserialize_offset_uint32(new_pos, input);\n        }\n        return (new_pos, opt_uint32(true, value));\n    }\n\n    function bcs_deserialize_opt_uint32(bytes memory input)\n        internal\n        pure\n        returns (opt_uint32 memory)\n    {\n        uint256 new_pos;\n        opt_uint32 memory value;\n        (new_pos, value) = bcs_deserialize_offset_opt_uint32(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct OptionU32 {\n        opt_uint32 value;\n    }\n\n    function bcs_serialize_OptionU32(OptionU32 memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = bcs_serialize_opt_uint32(input.value);\n        return result;\n    }\n\n    function bcs_deserialize_offset_OptionU32(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, OptionU32 memory)\n    {\n        uint256 new_pos = pos;\n        opt_uint32 memory value;\n        (new_pos, value) = bcs_deserialize_offset_opt_uint32(new_pos, input);\n        return (new_pos, OptionU32(value));\n    }\n\n    function bcs_deserialize_OptionU32(bytes memory input)\n        internal\n        pure\n        returns (OptionU32 memory)\n    {\n        uint256 new_pos;\n        OptionU32 memory value;\n        (new_pos, value) = bcs_deserialize_offset_OptionU32(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    function bcs_serialize_uint8(uint8 input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n      return abi.encodePacked(input);\n    }\n\n    function bcs_deserialize_offset_uint8(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, uint8)\n    {\n        uint8 value = uint8(input[pos]);\n        return (pos + 1, value);\n    }\n\n    struct ChainId {\n        CryptoHash value;\n    }\n\n    function bcs_serialize_ChainId(ChainId memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = bcs_serialize_CryptoHash(input.value);\n        return result;\n    }\n\n    function bcs_deserialize_offset_ChainId(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, ChainId memory)\n    {\n        uint256 new_pos = pos;\n        CryptoHash memory value;\n        (new_pos, value) = bcs_deserialize_offset_CryptoHash(new_pos, input);\n        return (new_pos, ChainId(value));\n    }\n\n    function bcs_deserialize_ChainId(bytes memory input)\n        internal\n        pure\n        returns (ChainId memory)\n    {\n        uint256 new_pos;\n        ChainId memory value;\n        (new_pos, value) = bcs_deserialize_offset_ChainId(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct MessageId {\n        ChainId chain_id;\n        BlockHeight height;\n        uint32 index;\n    }\n\n    function bcs_serialize_MessageId(MessageId memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = bcs_serialize_ChainId(input.chain_id);\n        result = abi.encodePacked(result, bcs_serialize_BlockHeight(input.height));\n        result = abi.encodePacked(result, bcs_serialize_uint32(input.index));\n        return result;\n    }\n\n    function bcs_deserialize_offset_MessageId(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, MessageId memory)\n    {\n        uint256 new_pos = pos;\n        ChainId memory chain_id;\n        (new_pos, chain_id) = bcs_deserialize_offset_ChainId(new_pos, input);\n        BlockHeight memory height;\n        (new_pos, height) = bcs_deserialize_offset_BlockHeight(new_pos, input);\n        uint32 index;\n        (new_pos, index) = bcs_deserialize_offset_uint32(new_pos, input);\n        return (new_pos, MessageId(chain_id, height, index));\n    }\n\n    function bcs_deserialize_MessageId(bytes memory input)\n        internal\n        pure\n        returns (MessageId memory)\n    {\n        uint256 new_pos;\n        MessageId memory value;\n        (new_pos, value) = bcs_deserialize_offset_MessageId(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct OptionMessageId {\n        opt_MessageId value;\n    }\n\n    function bcs_serialize_OptionMessageId(OptionMessageId memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = bcs_serialize_opt_MessageId(input.value);\n        return result;\n    }\n\n    function bcs_deserialize_offset_OptionMessageId(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, OptionMessageId memory)\n    {\n        uint256 new_pos = pos;\n        opt_MessageId memory value;\n        (new_pos, value) = bcs_deserialize_offset_opt_MessageId(new_pos, input);\n        return (new_pos, OptionMessageId(value));\n    }\n\n    function bcs_deserialize_OptionMessageId(bytes memory input)\n        internal\n        pure\n        returns (OptionMessageId memory)\n    {\n        uint256 new_pos;\n        OptionMessageId memory value;\n        (new_pos, value) = bcs_deserialize_offset_OptionMessageId(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n} // end of library LineraTypes\n\n&quot;;</code></pre></section></div></main></body></html>