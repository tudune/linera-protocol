searchState.loadedDescShard("scylla", 0, "Async Rust driver for the Scylla database written in Rust. …\nDerive macro for the <code>DeserializeRow</code> trait that generates …\nDerive macro for the <code>DeserializeValue</code> trait that generates …\nDerive macro for the <code>SerializeRow</code> trait which serializes …\nDerive macro for the <code>SerializeValue</code> trait which serializes …\nThis module holds entities that represent the whole …\nThis module holds entities that represent the cluster as a …\nDeserializing DB response containing CQL query results.\nThis module contains various errors which can be returned …\nThis module holds entities that allow observing and …\nThis module holds policies, which are entities that allow …\nThis module holds entities that represent responses to …\nThis module holds entities whose goal is to enable routing …\nSerializing bound values of a query to be sent to the DB.\nThis module holds entities representing various kinds of …\nType to represent an authentication error message.\nTrait used to represent a factory of <code>AuthenticatorSession</code> …\nTrait used to represent a user-defined custom …\nDefault authenticator provider that requires username and …\nTo handle an authentication challenge initiated by the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates new <code>PlainTextAuthenticator</code> instance with provided …\nA pair of initial response and boxed <code>AuthenticatorSession</code> …\nTo handle the success phase of exchange. The token …\nThe wire protocol compression algorithm.\nLZ4 compression algorithm.\nA delay with millisecond granularity.\nIndicates that the pool should establish given number of …\nIndicates that the pool should establish given number of …\nThe target size of a per-node connection pool.\nDriver and application self-identifying information, to be …\nA delay implemented by yielding a tokio task. This should …\nSnappy compression algorithm.\nRepresents a write coalescing delay configuration option.\n<code>ExecutionProfile</code> is a grouping of configurable options …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nApplication name to be advertised. See …\nApplication version to be advertised. See …\nClient ID to be advertised. See Self::set_client_id for …\nCustom driver name to be advertised. See …\nCustom driver version to be advertised. See …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEntities that provide automated transparent paging of a …\n<code>Session</code> is the main object used in the driver. It manages …\nSessionBuilder provides an easy way to create new Sessions\nAdvertises an application name, which can be used to …\nAdvertises an application version. See …\nAdvertises a client ID, which can be set to distinguish …\nAdvertises a custom driver name, which can be used if a …\nAdvertises a custom driver version. See …\nAdvertises an application name. See …\nAdvertises an application version. See …\nAdvertises a client ID. See Self::set_client_id for use …\nAdvertises a custom driver name. See …\nAdvertises a custom driver version. See …\nProvides auto caching while executing queries\nAdds a prepared statement to the cache\nDoes the same thing as <code>Session::batch</code> but uses the …\nDoes the same thing as <code>Session::execute_iter</code> but uses the …\nDoes the same thing as <code>Session::execute_single_page</code> but …\nDoes the same thing as <code>Session::execute_unpaged</code> but uses …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPrepares all statements within the batch and returns a new …\nBuilds a <code>CachingSession</code> from a <code>Session</code>, a cache size, and …\nA profile that groups configurable options regarding …\n<code>ExecutionProfileBuilder</code> is used to create new …\nA handle that points to an ExecutionProfile.\nBuilds the ExecutionProfile after setting all the options.\nCreates a blank builder that can be used to construct new …\nSpecify a default consistency to be used for statement …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets consistency associated with this profile.\nGets load balancing policy associated with this profile.\nGets client timeout associated with this profile.\nGets retry policy associated with this profile.\nGets serial consistency (if set) associated with this …\nGets speculative execution policy associated with this …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns a new handle to this ExecutionProfile.\nReturns a new handle to this ExecutionProfile, tagging the …\nSets the load balancing policy. The default is …\nMakes the handle point to a new execution profile. All …\nCreates a builder having all options set to the same as …\nChanges client-side timeout. The default is 30 seconds.\nSets the <code>RetryPolicy</code> to use by default on statements. The …\nSpecify a default serial consistency to be used for …\nSets the speculative execution policy. The default is None.\nCreates a builder having all options set to the same as …\nReturns execution profile pointed by this handle.\nAn error returned that occurred during next page fetch.\nFailed to fetch next page of result.\nAn error returned by async iterator API.\nPK extraction and/or token calculation error. Applies only …\nAn intermediate object that allows to construct a stream …\nFailed to run a request responsible for fetching new page.\nFailed to deserialize result metadata associated with next …\nAn error occurred during row deserialization.\nReturned by QueryPager::rows_stream.\nReturns specification of row columns\nReturns specification of row columns\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCasts the iterator to a given row type, enabling Stream’…\nIf tracing was enabled, returns tracing ids of all …\nIf tracing was enabled returns tracing ids of all finished …\nType-checks the iterator against given type.\n<code>Session</code> manages connections to the cluster and allows to …\nConfiguration options for <code>Session</code>. Can be created …\nAdds a known database server with a hostname. If the port …\nAdds a known database server with an IP address\nAdds a list of known database server with hostnames. If …\nAdds a list of known database servers with IP addresses\nThe address translator is used to translate addresses …\nExecute a batch statement Batch contains many <code>unprepared</code> …\nInterval between refreshing cluster metadata. This can be …\nPreferred compression algorithm to use on connections. If …\nEstabilishes a CQL session with the database\nSize of the per-node connection pool, i.e. how many …\nIf true, prevents the driver from connecting to the …\nIf true, the driver will inject a delay controlled by …\nExecute a prepared statement with paging. This method will …\nExecutes a prepared statement, restricting results to …\nExecute a prepared statement. Requires a PreparedStatement …\nIf true, full schema is fetched with every metadata …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAccess cluster state visible by the driver.\nRetrieves the handle to execution profile that is used by …\nGets the name of the keyspace that is currently set, or …\nGet <code>TracingInfo</code> of a traced query performed earlier\nThe host filter decides whether any connections should be …\nDriver and application self-identifying information, to be …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInterval of sending keepalive requests. If <code>None</code>, …\nControls after what time of not receiving response to …\nIf empty, fetch all keyspaces\nList of database servers known on Session startup. Session …\nA local ip address to bind all driver’s TCP sockets to.\nCustom timeout for requests that query metadata.\nCreates a <code>SessionConfig</code> with default configuration\nPrepares a statement on the server side and returns a …\nPrepares all statements within the batch and returns a new …\nExecute an unprepared CQL statement with paging This …\nQueries a single page from the database, optionally …\nSends a request to the database and receives a response. …\nManually trigger a metadata refresh The driver will fetch …\nIf true, full schema metadata is fetched after …\nControls whether schema agreement is automatically awaited …\nHow often the driver should ask if schema is in agreement.\nControls the timeout for waiting for schema agreement. …\nSpecifies the local port range used for shard-aware …\nTimestamp generator used for generating timestamps on the …\nProvide our Session with TLS\nNumber of attempts to fetch <code>TracingInfo</code> in …\nConsistency level of fetching <code>TracingInfo</code> in …\nDelay between attempts to fetch <code>TracingInfo</code> in …\nSends <code>USE &lt;keyspace_name&gt;</code> request on all connections This …\nControls the write coalescing delay (if enabled).\nSessionBuilder is used to create new Session instances\nUses a custom address translator for peer addresses …\nSet custom authenticator provider to create an …\nControls automatic waiting for schema agreement after a …\nBuilds the Session after setting all the options.\nSet the interval at which the driver refreshes the cluster …\nSet preferred Compression algorithm. The default is no …\nChanges connection timeout The default is 5 seconds. If it…\nSet the custom identity of the driver/application/instance,\nSet the default execution profile using its handle\nIf true, prevents the driver from connecting to the …\nSet the fetch schema metadata flag. The default is true.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSets the host filter. The host filter decides whether any …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet the keepalive interval. The default is …\nSet the keepalive timeout. The default is …\nSet the keyspaces to be fetched, to retrieve their …\nAdd a known node with a hostname\nAdd a known node with an IP address\nAdd a list of known nodes with hostnames\nAdd a list of known nodes with IP addresses\nSets the local ip address all TCP sockets are bound to.\nSet the server-side timeout for metadata queries. The …\nCreates new SessionBuilder with default configuration\nSets the per-node connection pool size. The default is one …\nSet the refresh metadata on schema agreement flag. The …\nSet the delay for schema agreement check. How often driver …\nSets the timeout for waiting for schema agreement. By …\nSpecifies the local port range used for shard-aware …\nSet the TCP keepalive interval. The default is <code>None</code>, which …\nSet the nodelay TCP flag. The default is true.\nSet the timestamp generator that will generate timestamps …\nTLS feature\nSet the number of attempts to fetch TracingInfo in …\nSet the consistency level of fetching TracingInfo in …\nSet the delay between attempts to fetch TracingInfo in …\nSet keyspace to be used on all connections. Each …\nSet username and password for plain text authentication. …\nIf true, the driver will inject a delay controlled by …\nControls the write coalescing delay (if enabled).\nDescribes a database server known on <code>Session</code> startup.\nNode represents a cluster node along with its data and …\nThis enum is introduced to support address translation …\nA way that Nodes are often passed and accessed in the …\nFetched in Metadata with <code>query_peers()</code> (broadcast by a …\nBuilt from control connection’s address upon …\nCompute token of a table partition key\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAccess to replicas owning a given partition key (similar …\nAccess keyspace details collected by the driver.\nAccess details about nodes known to the driver\nAccess to replicas owning a given token\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if the driver has any open connections in the …\nReturns a boolean which indicates whether this node was is …\nReturns an iterator over keyspaces.\nThis module holds entities that represent the cluster …\nAccess replica location info\nCollection types: Map, Set, and List. Those are composite …\nCollection variants of ColumnType. A collection is a …\nDescribes a column of the table.\nColumnKind parse error\nA type of:\nDescribes a keyspace in the cluster.\nDescribes a materialized view in the cluster.\nTypes that are “simple” (non-recursive).\nA ColumnType variants that are “simple” …\nDescribes a table in the cluster.\nA composite type with a defined size and elements of …\nDefinition of a user-defined type\nA C-struct-like type defined by the user.\nA composite list-like type that has a defined size and all …\nNames of the column of clustering key. All of the names …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nNames of the column of partition key. All of the names are …\nEmpty HashMap may as well mean that the client disabled …\nEmpty HashMap may as well mean that the client disabled …\nEmpty HashMap may as well mean that the client disabled …\nAn error indicating that a failure happened during …\nA reference to a part of the frame.\nAn error indicating that a failure happened during type …\nReturns a reference to the Bytes object which encompasses …\nReturns the subslice.\nReturns a mutable reference to the subslice.\nRetrieve an error reason by downcasting to specific type.\nRetrieve an error reason by downcasting to specific type.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the slice has length of 0.\nCreates a new FrameSlice from a reference of a Bytes …\nConstructs a new <code>TypeCheckError</code>.\nConstructs a new <code>DeserializationError</code>.\nCreates an empty FrameSlice.\nReads and consumes a <code>[bytes]</code> item from the beginning of …\nDeserializing the whole query result contents.\nDeserializing a row of the query result.\nReturns a new Bytes object which is a subslice of the …\nDeserializing a single CQL value from a column of the …\nA typed version of RawRowIterator which deserializes the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new TypedRowIterator from given RawRowIterator.\nReturns the remaining number of rows that this iterator is …\nReturns information about the columns of rows that are …\nFailed to deserialize a row from the DB response, …\nDescribes why deserializing a result row failed.\nFailed to type check incoming result column types again …\nDescribes why type checking incoming result column types …\nOne of the columns failed to deserialize.\nIterates over columns of a single row.\nA different column name was expected at given position.\nColumn type check failed between Rust type and DB type at …\nThe CQL row contains a column for which a corresponding …\nA type that can be deserialized from a row that was …\nDuplicated column in DB metadata.\nRepresents a raw, unparsed column value.\nOne of the raw columns failed to deserialize, most probably\nSeveral values required by the Rust type are not provided …\nThe Rust type expects <code>rust_cols</code> columns, but the statement …\nReturns the remaining number of columns that this iterator …\nThe CQL types of the values that the Rust type was being …\nDeserializes a row from given column iterator.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDetailed information about the failure.\nDetailed information about the failure.\nCreates a new iterator over a single row.\nName of the Rust type used to represent the values.\nName of the Rust type used to represent the row.\nChecks that the schema of the result matches what this …\nIndex of the column that failed to deserialize.\nIndex of the raw column that failed to deserialize.\nName of the column that failed to deserialize.\nName of the raw column that failed to deserialize.\nThe error that caused the column deserialization to fail.\nThe error that caused the raw column deserialization to …\nIndex of the excess column.\nIndex of the column having mismatched name.\nIndex of the column.\nColumn index of the second occurrence of the column with …\nName of the column that is present in CQL row but not in …\nName of the column, as provided by the DB.\nThe name of the duplicated column.\nNames of the columns in the Rust type for which the DB …\nThe number of columns that the statement operates on.\nName of the column for which the DB requested a value.\nInner type check error due to the type mismatch.\nIndex of the field determining the expected name.\nThe number of values that the Rust type provides.\nName of the column, as expected by the Rust type.\nFailed to deserialize one of date’s fields.\nFailed to deserialize decimal’s scale.\nThe length of read value in bytes is not suitable for IP …\nDeserialization of one of the built-in types failed.\nDescribes why deserialization of some of the built-in …\nType checking of one of the built-in types failed.\nDescribes why type checking some of the built-in types …\nThe length of read value in bytes is different than …\nA type that can be deserialized from a column value inside …\nDuplicated field in serialized data.\nOne of the elements of the set/list failed to deserialize.\nIncompatible element types.\nValues that may be empty or not.\nUDT contains an excess field, which does not correspond to …\nExpected valid ASCII string.\nExpected non-null value, got null.\nOne of the tuple fields failed to deserialize.\nA different field name was expected at given position.\nThe CQL type and the Rust type of a tuple field failed to …\nType check failed between UDT and Rust type field.\nInvalid UTF-8 string.\nOne of the keys in the map failed to deserialize.\nIncompatible key types.\nFailed to deserialize set or list’s length.\nFailed to deserialize map’s length.\nAn iterator over either a CQL set or list.\nDescribes why deserialization of a map type failed.\nA type check failure specific to a CQL map.\nA deserialization failure specific to a CQL map.\nAn iterator over a CQL map.\nDescribes why type checking of a map type failed.\nA value that may be empty or not.\nExpected one from a list of particular types.\nThe CQL type is not a map.\nThe CQL type is not a set.\nThe CQL type is neither a set not a list.\nThe CQL type is not a tuple.\nThe CQL type is not a user defined type.\nFailed to deserialize raw bytes of cql value.\nDescribes why deserialization of a set or list type failed.\nA type check failure specific to a CQL set or list.\nA deserialization failure specific to a CQL set or list.\nDescribes why type checking of a set or list type failed.\nFewer fields present in the UDT than required by the Rust …\nDescribes why deserialization of a tuple failed.\nA type check failure specific to a CQL tuple.\nA deserialization failure specific to a CQL tuple.\nDescribes why type checking of a tuple failed.\nA type check failure specific to a CQL UDT.\nA deserialization failure specific to a CQL UDT.\nAn iterator over fields of a User Defined Type.\nDescribes why type checking of a user defined type failed.\nDeserialization of this CQL type is not supported by the …\nOne of the values in the map failed to deserialize.\nThe read value is out of range supported by the Rust type.\nIncompatible value types.\nThe CQL UDT type does not have some fields that is …\nThe tuple has the wrong element count.\nThe CQL type that the Rust type was being deserialized …\nThe CQL type that the Rust type was being deserialized …\nDeserialize a column value from given serialized …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDetailed information about the failure.\nDetailed information about the failure.\nName of the Rust type being deserialized.\nName of the Rust type being deserialized.\nChecks that the column type matches what this type expects.\nThe list of types that the Rust type can deserialize from.\nThe error that caused the tuple field deserialization to …\nIndex of the tuple field that failed to deserialize.\nThe number of elements that the CQL tuple type has.\nThe type check error that occurred.\nThe index of the field whose type check failed.\nThe number of elements that the Rust tuple has.\nThe name of the CQL UDT field.\nThe name of the CQL UDT field.\nInner type check error that occurred.\nThe name of the duplicated field.\nThe name of the field whose type check failed.\nNames of fields that the Rust struct requires but are …\nIndex of the field in the Rust struct.\nThe name of the Rust field.\nFailed to prepare statement on every connection from the …\nAttempted to create a keyspace or a table that was already …\nAn error returned by …\nAn error returned by <code>AuthenticatorSession::success</code>.\nFailed to serialize AUTH_RESPONSE request.\nAuthentication failed - bad credentials\nInvalid keyspace name given to <code>Session::use_keyspace()</code>\nPassed invalid keyspace name to use.\nError caused by caller creating an invalid statement.\nCaller passed an invalid statement.\nLogged batch write. If this type is received, it means the …\nTimeout occurred during the write to the batch log when a …\nFailed to serialize BATCH request.\nFailed to read frame body from the socket.\nFailed to deserialize body extensions of frame received on …\nFailed to deserialize frame body extensions.\nFailed to deserialize frame body extensions.\nA connection pool is broken. Includes an error of a last …\nA connection has been broken after being established.\nA connection was broken during setup request execution.\nAn error indicating that a connection was broken. Possible …\nA connection has been broken during query execution.\nA reason why connection was broken.\nTimeout occurred during Compare And Set write/update\nTimeout occurred  when a cdc_total_space_in_mb is exceeded …\nFailed to send data via tokio channel. This implies that …\nCircular UDT dependency detected.\nError returned from ClusterState APIs.\nThe query is invalid because of some configuration issue\nProvided connect timeout elapsed.\nConnection was closed before whole frame was read.\nAn error that appeared on a connection level. It indicated …\nAn error that occurred when selecting a node connection to …\nSelected node’s connection pool is in invalid state.\nFailed to find a node with working connection pool.\nFailed to find a node with working connection pool.\nControl connection pool error.\nSelected node’s connection pool is in invalid state.\nAn error that occurred during connection setup request …\nA request required to initialize a connection failed.\nCounter write (batched or not)\nAn error type returned when deserialization of …\nReceived an AUTH_CHALLENGE response, but failed to …\nAn error type returned when deserialization of …\nReceived an AUTH_SUCCESS response, but failed to …\nAn error type returned when deserialization of …\nReceived an AUTHENTICATE response, but failed to …\nAn error type returned when deserialization of ERROR …\nReceived server ERROR response, but failed to deserialize …\nReceived an ERROR server response, but failed to …\nFailed to handle a CQL event received on a stream -1. …\nFailed to handle a CQL event (server response received on …\nAn error type returned when deserialization of <code>EVENT</code> …\nReceived an EVENT server response, but failed to …\nPossible requests sent by the client.\nFailed to serialize CQL request.\nFailed to serialize CQL request.\nAn error that occurred during CQL request serialization.\nPossible CQL responses received from the server\nAn error type returned when deserialization of CQL server …\nAn error type returned when deserialization of RESULT …\nReceived a RESULT server response, but failed to …\nAn error type returned when deserialization of SUPPORTED …\nReceived a response to OPTIONS request, but failed to …\nFailed to deserialize frame’s custom payload.\nAn error sent from the database in response to a query as …\nReceived a server error in response to connection setup …\nDatabase sent a response containing some error with a …\nAn error indicating that a failure happened during …\nKeyspace name is empty\nList of known nodes passed to Session constructor is empty …\nEmpty peers list returned during peers metadata fetch.\nLoad balancing policy returned an empty plan.\nLoad balancing policy returned an empty plan.\nAll tracing queries returned an empty result.\nAll peers have empty token lists.\nFailed to serialize EXECUTE request.\nError that occurred during request execution\nFailed to execute query to either “system_traces.sessions…\nFailed to resolve hostname passed in Session creation\nFailed to fetch metadata.\nAn error returned by <code>parse_response_body_extensions</code>.\nReceived a frame marked as coming from a client.\nAn error that occurred during frame header deserialization.\nFailed to deserialize response frame header.\nUser defined function failed during execution\nFailed to read the frame header from the socket.\nIllegal character - only alphanumeric and underscores …\nA connection pool is still being initialized.\nThe query is syntactically correct but invalid\nA translation rule for a provided address was found, but …\nQueried table has invalid column type.\nFailed to parse CQL type returned from system_schema.types …\nFailed to parse CQL type returned from …\nInput/Output error occurred.\nAn I/O error occurred during address translation.\nThe coordinator node is still bootstrapping\nDriver sent a keepalive request to the database, but …\nDriver sent a keepalive request to the database, but the …\nKeyspace name mismatch.\nAn error that occurred during specific keyspace’s …\nBad keyspaces metadata.\nAn error that occurred during keyspaces metadata fetch.\nAn error returned by last attempt of request execution.\nFailed to execute request.\nFailed to decompress frame body (lz4).\nAn error that occurred during metadata fetch and …\nA metadata error occurred during schema agreement.\nFailed to perform initial cluster metadata fetch.\nAn error occurred during metadata fetch.\nSpecific reason why metadata fetch failed.\nUser did not provide authentication while the cluster …\nKeyspace strategy map missing a <code>class</code> field.\nMissing replication factor for SimpleStrategy.\nError that occurred during session creation\nFailed to fetch the first page of the result.\nFailed to obtain next row from response to the metadata …\nFrame is compressed, but no compression was negotiated for …\nDriver failed to find a translation rule for a provided …\nDriver was unable to find a free source port for given …\nA corresponding node was disabled by a host filter.\nA result with nonfinished paging state received for …\nType of the operation rejected by rate limiting\nOther error code not specified in the specification\nOther type not specified in the specification\nThe request cannot be processed because the coordinator …\nAn error that occurred during construction of <code>QueryPager</code>.\nUnable extract a partition key based on prepared statement…\nBad peers metadata.\nAn error that occurred during peers metadata fetch.\nAn error returned by <code>Session::prepare()</code>.\nFailed to prepare the statement. Applies to unprepared …\nFailed to prepare the statement.\nFailed to prepare the statement for metadata fetch.\nFailed to serialize PREPARE request.\nPrepared statement id mismatch.\nInvalid protocol message received from the driver\nFailed to serialize QUERY request.\nRate limit was exceeded for a partition affected by the …\nA non-timeout error during a read request\nNot enough nodes responded to the read request in time to …\nFailed to serialize REGISTER request.\nReplication factor could not be parsed as unsigned integer.\nPrepared statement id changed after repreparation.\nDriver tried to reprepare a statement in the batch, but …\nAn error that occurred during a single attempt of:\nAn error that occurred during execution of\nAn error during request execution.\nFailed to execute schema version query on one of the …\nFailed to run a request within a provided client timeout.\nFailed to run a request within a provided client timeout.\nFailed to run a request within a provided client timeout.\nAn error that occurred when awating schema agreement.\nFailed to await automatic schema agreement.\nDriver failed to send event data between the internal …\nFailed to serialize values required to compute partition …\nAn error indicating that a failure happened during …\nFailed to serialize statement parameters.\nFailed to serialize statement parameters.\n“Serializing values failed.\nFailed to serialize query parameters. This error occurs, …\nInternal server error. This indicates a server-side bug\nNon-batched non-counter write\nFailed to deserialize a single row from schema version …\nRequest body compression failed.\nFailed to decompress frame body (snap).\nAn error returned by …\nFailed to serialize STARTUP request.\nBad keyspace replication strategy.\nThe submitted query has a syntax error\nBad tables metadata.\nAn error that occurred during tables metadata fetch.\nSchema agreement timed out.\nA wrapper around a TLS error.\nFailed to calculate token.\nKeyspace name too long, must be up to 48 characters\nMaximum number of orphaned streams exceeded.\nToo many statements in the batch statement.\nFailed to deserialize frame trace id.\nResponse to system_traces.events failed to deserialize.\nFailed to convert schema version query result into rows …\nFailed to convert result of system_traces.events query to …\nsystem_traces.events has invalid column type.\nResponse to system_traces.session failed to deserialize.\nFailed to convert result of system_traces.session query to …\nsystem_traces.session has invalid column type.\nAn error that occurred during tracing info fetch.\nError caused by failed address translation done before …\nFailed to translate an address before establishing a …\nError during truncate operation\nAn error indicating that a failure happened during type …\nAn error that occurred during UDTs metadata fetch.\nBad UDTs metadata.\nDriver was unable to allocate a stream id to execute a …\nDriver was unable to allocate a stream id to execute a …\nThe logged user doesn’t have the right to perform the …\nNot enough nodes are alive to satisfy required consistency …\nReceived an unexpected NTS option. Driver expects only ‘…\nReceived an unexpected response from the server.\nReceived an unexpected response on stream -1.\nReceived an unexpected response from the server.\nReceived a server frame with unexpected stream id.\nUnknown column kind.\nReceived unknown response opcode.\nClusterState doesn’t currently have metadata for the …\nUnlogged batch. No batch log write has been attempted.\nTried to execute a prepared statement that is not …\nAn error that occurred during <code>USE KEYSPACE &lt;&gt;</code> request.\n‘USE KEYSPACE &lt;&gt;’ request failed.\n‘USE KEYSPACE &lt;&gt;’ request failed.\nSerialized values are too long to compute partition key.\nReceived a frame with unsupported version.\nWrite involves VIEW update and failure to acquire local …\nFailed to deserialize warnings attached to frame.\nIO error - server failed to write data to the socket.\nA non-timeout error during a write request\nNot enough nodes responded to the write request in time to …\nType of write operation requested\nDecides whether the error can be ignored. If true, the …\nRetrieve an error reason by downcasting to specific type.\nReason why metadata fetch failed.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks if this error indicates that a chosen source …\nTable name for which metadata fetch failed.\nFound number of active nodes\nTypes of arguments passed to the function\nConsistency level of the query\nConsistency level of the query\nConsistency level of the query\nConsistency level of the query\nConsistency level of the query\nReplica that was asked for data has responded\nReplica that was asked for data has responded\nName of the failed function\nCreated keyspace name or name of the keyspace in which …\nKeyspace of the failed function\nNumber of nodes that experience a failure while executing …\nNumber of nodes that experience a failure while executing …\nType of the operation rejected by rate limiting.\nNumber of nodes that responded to the read request\nNumber of nodes that responded to the write request\nNumber of nodes that responded to the read request\nNumber of nodes that responded to the read request\nWhether the operation was rate limited on the coordinator …\nNumber of nodes required to be alive to satisfy required …\nNumber of nodes required to respond to satisfy required …\nNumber of nodes required to respond to satisfy required …\nNumber of nodes required to respond to satisfy required …\nNumber of nodes required to respond to satisfy required …\nStatement id of the requested prepared query\nName of the table created, in case of keyspace creation it…\nType of write operation requested\nType of write operation requested\nThe wire protocol compression algorithm.\nLZ4 compression algorithm.\nSnappy compression algorithm.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFailed to serialize AUTH_RESPONSE request.\nAn error type returned when serialization of AUTH_RESPONSE …\nNumber of announced batch statements differs from actual …\nFailed to serialize paging state.\nFailed to serialize BATCH request.\nAn error type returned when serialization of BATCH request …\nAn error type returned when serialization of one of the …\nFailed to read frame body from the socket.\nAn error type returned when deserialization of […\nFailed to parse column count.\nFailed to parse column count.\nFailed to parse column count.\nAn error type returned when deserialization of table …\nFailed to parse column spec.\nFailed to parse column spec.\nThe type of error that appeared during deserialization of …\nConnection was closed before whole frame was read.\nAn error type returned when deserialization of …\nAn error type returned when deserialization of …\nAn error type returned when deserialization of …\nAn error type returned when deserialization of ERROR …\nAn error type returned when deserialization of <code>EVENT</code> …\nAn error that occurred during CQL request serialization.\nAn error type returned when deserialization of CQL server …\nAn error type returned when deserialization of RESULT …\nAn error type returned when deserialization of SUPPORTED …\nAn error type returned when deserialization of CQL type …\nFailed to deserialize frame’s custom payload.\nFailed to serialize event types list.\nFailed to serialize EXECUTE request.\nAn error type returned when serialization of EXECUTE …\nFailed to parse metadata flags.\nFailed to parse metadata flags.\nFailed to parse metadata flags.\nAn error returned by <code>parse_response_body_extensions</code>.\nReceived a frame marked as coming from a client.\nAn error that occurred during frame header deserialization.\nFailed to parse global table spec.\nFailed to parse global table spec.\nFailed to read the frame header from the socket.\nA low level deserialization error.\nFailed to decompress frame body (lz4).\nFrame is compressed, but no compression was negotiated for …\nFailed to serialize startup options.\nFailed to parse paging state response.\nFailed to parse paging state response.\nFailed to parse partition key count.\nFailed to parse partition key index.\nFailed to serialize PREPARE request.\nAn error type returned when serialization of PREPARE …\nAn error type returned when deserialization of statement’…\nAn error type returned when deserialization of <code>RESULT::</code>…\nFailed to serialize query parameters.\nFailed to serialize query parameters.\nAn error type returned when serialization of query …\nFailed to serialize QUERY request.\nAn error type returned when serialization of QUERY request …\nAn error that occurred during initial deserialization of …\nFailed to serialize REGISTER request.\nAn error type returned when serialization of REGISTER …\nMaximum response’s body length exceeded.\nAn error returned when lazy deserialization of result …\nAn error type returned when deserialization of result …\nFailed to deserialize result metadata.\nReceived malformed rows count from the server.\nAn error type returned when deserialization of …\nRequest body compression failed.\nFailed to decompress frame body (snap).\nFailed to serialize STARTUP request.\nAn error type returned when serialization of STARTUP …\nMaximum value of statement id exceeded.\nFailed to serialize prepared statement id.\nFailed to serialize a statement in the batch.\nFailed to serialize the CQL statement string.\nFailed to serialize the CQL statement string.\nFailed to serialize the CQL statement string.\nAn error type returned when deserialization of table …\nMaximum number of batch statements exceeded.\nToo many bound values provided.\nFailed to deserialize frame trace id.\nReceived unknown response opcode.\nNumber of batch statements differs from number of provided …\nFailed to serialize statement’s bound values.\nReceived a frame with unsupported version.\nFailed to deserialize warnings attached to frame.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCollection types: Map, Set, and List. Those are composite …\nCollection variants of ColumnType. A collection is a …\nA type of:\nTypes that are “simple” (non-recursive).\nA ColumnType variants that are “simple” …\nA composite type with a defined size and elements of …\nDefinition of a user-defined type\nA C-struct-like type defined by the user.\nA composite list-like type that has a defined size and all …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nindex in the serialized values\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nsequence number in partition key\nCollecting history of request executions - retries, …\nId of a single attempt within a request run - a single …\nHistoryCollector can be used as HistoryListener to collect …\nAny type implementing this trait can be passed to Session …\nId of a single request, i.e. a single call to …\nId of a speculative execution fiber. When speculative …\nStructured representation of requests history. …\nClones the data collected by the collector.\nClone the collected events and convert them to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLog that an attempt ended with an error. The error and …\nLog that an attempt has started - request has been sent on …\nLog that an attempt succeeded.\nLog that a new speculative fiber has started.\nLog that request ended with an error - called right before …\nLog that a request has started on request start - right …\nLog that request was successful - called right before …\nCreates a new HistoryCollector with empty data.\nTakes the data out of the collector. The collected events …\nTake the collected events out, just like in <code>take_collected</code> …\nA single event happening during a traced query\nTracing info retrieved from <code>system_traces.sessions</code> with …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns a list of unique nodes involved in the query\nstarted_at is a timestamp - time since unix epoch\nHost filters.\nLoad balancing configurations <code>Session</code> can use any load …\nTranslates IP addresses received from ScyllaDB nodes into …\nData used to issue connections to a node that is possibly …\nThe datacenter the node resides in.\nReturns the argument unchanged.\nThe unique identifier of the node in the cluster.\nCalls <code>U::from(self)</code>.\nThe rack the node resides in.\nThe address of the node in the cluster as broadcast by the …\nUnconditionally accepts all nodes.\nAccepts nodes whose addresses are present in the allow …\nAccepts nodes from given DC.\nThe <code>HostFilter</code> trait.\nReturns whether a peer should be accepted or not.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new <code>AllowListHostFilter</code> which only accepts nodes …\nCreates a new <code>DcHostFilter</code> that accepts nodes only from the\nThe default load balancing policy.\nThe intended way to instantiate the DefaultPolicy.\nThe fallback list of nodes in the request plan.\nThe builder of LatencyAwareness module of DefaultPolicy.\nPolicy that decides which nodes and shards to contact for …\nThe list of targets constituting the query plan. Target …\nRepresents info about statement that can be used by load …\nBuilds a new DefaultPolicy with the previously set …\nCreates a builder used to customise configuration of a new …\nRequested consistency information allows to route requests …\nSets whether this policy should shuffle replicas when …\nSets exclusion threshold for latency awareness (a …\nReturns all contact-appropriate nodes for a given request.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf, while preparing, we received from the cluster …\nLatency awareness is a mechanism that penalises nodes …\nSets minimum measurements for latency awareness (if there …\nReturns the name of load balancing policy.\nCreates a builder used to customise configuration of a new …\nCreates a builder of LatencyAwareness module of …\nInvoked each time a request fails.\nInvoked each time a request succeeds.\nSets whether this policy permits datacenter failover, i.e. …\nReturns the first node to contact for a given request.\nSets the datacenter to be preferred by this policy.\nSets the datacenter and rack to be preferred by this …\nSets retry period for latency awareness (max time that a …\nSets the scale to use for the resulting latency aware …\nInformation that are the basis of token-aware routing:\nSets whether this policy is token-aware (balances load …\nSets update rate for latency awareness (how often is the …\nDefault retry policy - retries when there is a high chance …\nFails the whole request.\nDowngrading consistency retry policy - retries with lower …\nForwards all errors directly to the user, never retries\nWill cause the driver to return an empty successful …\nInformation about a failed request\nReturned by implementations of RetryPolicy. Instructs the …\nRequest will be sent to the next target generated by load …\nSpecifies a policy used to decide when to retry a request\nRequest will be sent to the same shard on the same host.\nUsed throughout a single request to decide when to retry it\nConsistency with which the request failed\nCalled after the request failed - decide what to do next\nThe error with which the request failed\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA request is idempotent if it can be applied multiple …\nCalled for each new request, starts a session of deciding …\nReset before using for a new request\nContext is passed as an argument to …\nA SpeculativeExecutionPolicy that schedules a given number …\nThe policy that decides if the driver will send …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe maximum number of speculative executions that will be …\nThe maximum number of speculative executions that will be …\nThe delay between each speculative execution\nThe delay between each speculative execution\nMonotonic timestamp generator. Guarantees monotonicity of …\nBasic timestamp generator. Provides no guarantees, if …\nTrait used to represent a timestamp generator\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new monotonic timestamp generator with default …\nThis generates a new timestamp\nThe state of a paged query, i.e. where to resume fetching …\nReturns the inner representation of PagingState. One can …\nDetermines if the query has finished or it should be …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the response into ControlFlow, signalling whether …\nCreates PagingState from its inner representation. One can …\nA start state - the state of a not-yet-started paged query.\nA view over specification of columns returned by the …\nDeserialization failed\nDeserialization failed\nDeserialization failed\nAn error returned by <code>QueryRowsResult::first_row</code>.\nAn error returned by <code>QueryResult::into_rows_result</code>\nAn error returned by <code>QueryRowsResult::maybe_first_row</code>.\nResult of a single request to the database. It represents …\nEnables deserialization of rows received from the database …\nFailed to lazily deserialize result metadata.\nResult is not of Rows kind\nAn error returned by <code>QueryResult::result_not_rows</code>.\nThe request response was of Rows type, but no rows were …\nAn error returned by <code>QueryRowsResult::rows</code>.\nAn error returned by <code>QueryRowsResult::single_row</code>.\nType check failed\nType check failed\nType check failed\nType check failed\nExpected one row, but got a different count\nReturns a slice of col specs encompassed by this struct.\nReturns column specifications.\nReturns the first row of the received result.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns specification of k-th column returned from the …\nReturns specification of the column with given name …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTransforms itself into the Rows result type to enable …\nReturns a bool indicating the current response is of Rows …\nReturns iterator over specification of columns returned …\nReturns number of columns.\nReturns <code>Option&lt;R&gt;</code> containing the first row of the result.\nCreates new <code>ColumnSpecs</code> wrapper from a slice.\nReturns <code>Ok</code> for a request’s result that shouldn’t …\nReturns an iterator over the received rows.\nReturns the size of the serialized rows.\nReturns the number of received rows.\nReturns the only received row.\nTracing ID associated with this CQL request.\nTracing ID associated with this CQL request.\nWarnings emitted by the database.\nWarnings emitted by the database.\nThe default shard-aware local port range - [49152, 65535].\nAn error returned by <code>ShardAwarePortRange::new()</code>.\nA range of ports that can be used for shard-aware …\nToken is a result of computing a hash of a primary key\nRandomly choose a source port <code>p</code> such that …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns iterator over source ports <code>p</code> such that …\nCreates a new <code>ShardAwarePortRange</code> with the given range.\nCreates a new token with given value, normalizing the …\nPartitioners are algorithms that can compute token for a …\nIf we connect to Scylla using Scylla’s shard aware port, …\n<code>ReplicaLocator</code> provides a way to find the set of owning …\nRepresents a set of replicas for a given token and …\nIterator that returns replicas from some replica set.\nRepresents a sequence of replicas for a given token and …\nIterator that returns replicas from some replica sequence, …\nA token ring is a continuous hash ring. It defines …\nChooses a random replica that satisfies the given …\nGives a list of all known datacenters.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTraverses the ring starting at the given token and returns …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the replica set into iterator. Order defined by …\nReturns <code>true</code> if the token ring contains no elements.\nReturns <code>true</code> if the replica set contains no elements.\nIterates over all members of the ring starting at the …\nGet the total number of members in the ring.\nGets the size of the set.\nReturns a set of nodes that are considered to be replicas …\nGives access to the token ring, based on which all token …\nProvides an iterator over the ring’s elements starting …\nProvides an iterator over the ring members starting at the …\nGives a list of all nodes in a specified datacenter ring …\nGives a list of all nodes in the token ring.\nA trait for creating instances of <code>PartitionHasher</code>, which …\nA trait for hashing a stream of serialized CQL values.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAn error indicating that a failure happened during …\nContains the BatchValues and BatchValuesIterator trait and …\nRetrieve an error reason by downcasting to specific type.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConstructs a new <code>SerializationError</code>.\nContains the SerializeRow trait and its implementations.\nContains the SerializeValue trait and its implementations.\nContains types and traits used for safe serialization of …\nRepresents a list of sets of values for a batch statement.\nImplements <code>BatchValues</code> from an <code>Iterator</code> over references to …\nAn <code>Iterator</code>-like object over the values from the parent …\nAn <code>Iterator</code>-like object over the values from the parent …\nImplements <code>BatchValuesIterator</code> from an <code>Iterator</code> over …\nA <code>BatchValuesIterator</code> over a tuple.\nReturns an iterator over the data contained in this object.\nReturn the number of sets of values, consuming the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether the next set of values is empty or not and …\nCreates a new `BatchValuesFromIter`` object.\nSerializes the next set of values in the sequence and …\nSkips the next set of values.\nFailed to serialize values for a statement, represented by …\nDescribes why serializing values for a statement failed.\nFailed to type check values for a statement, represented …\nDescribes why type checking values for a statement failed.\nA different column name was expected at given position.\nOne of the columns failed to serialize.\nThe Rust type provides a value for some column, but that …\nContains information needed to serialize a row.\nRepresents a set of values that can be sent along a CQL …\nToo many values to add, max 65,535 values can be sent in a …\nA value required by the statement is not provided by the …\nThe Rust type provides <code>rust_cols</code> columns, but the …\nReturns column/bind marker specifications for given query.\nConstructs an empty <code>RowSerializationContext</code>, as if for a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates the serialization context from prepared statement …\nCreates the serialization context directly from column …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether this row contains any values or not.\nDetailed information about the failure.\nDetailed information about the failure.\nName of the Rust type used to represent the values.\nName of the Rust type used to represent the values.\nSerializes the row according to the information in the …\nThe error that caused the column serialization to fail.\nName of the column that failed to serialize.\nThe number of columns that the statement operates on.\nName of the column for which the DB requested a value.\nName of the column that is missing in the statement.\nName of the column for which the Rust type doesn’t …\nThe number of values that the Rust type provides.\nName of the column, as expected by the Rust type.\nSerialization of one of the built-in types failed.\nDescribes why serialization of some of the built-in types …\nType checking of one of the built-in types failed.\nDescribes why type checking some of the built-in types has …\nOne of the elements of the set/list failed to serialize.\nOne of the tuple elements failed to serialize.\nA different field name was expected at given position.\nOne of the fields failed to serialize.\nOne of the keys in the map failed to serialize.\nA type check failure specific to a CQL map.\nA serialization failure specific to a CQL map.\nDescribes why serialization of a map type failed.\nDescribes why type checking of a map type failed.\nExpected one from a list of particular types.\nThe name of the UDT being serialized to does not match.\nThe Rust data contains a field that is not present in the …\nExpected a type that can be empty.\nThe CQL type is not a map.\nThe CQL type is neither a set not a list.\nThe CQL type is not a tuple.\nThe CQL type is not a user defined type.\nA type that can be serialized and sent along with a CQL …\nA type check failure specific to a CQL set or list.\nA serialization failure specific to a CQL set or list.\nDescribes why serialization of a set or list type failed.\nDescribes why type checking of a set or list type failed.\nThe size of the Rust value is too large to fit in the CQL …\nThe many contains too many items, exceeding the protocol …\nThe set/list contains too many items, exceeding the …\nA type check failure specific to a CQL tuple.\nA serialization failure specific to a CQL tuple.\nDescribes why serialize of a tuple failed.\nDescribes why type checking of a tuple failed.\nA type check failure specific to a CQL UDT.\nA serialization failure specific to a CQL UDT.\nDescribes why serialization of a user defined type failed.\nDescribes why type checking of a user defined type failed.\nThe Rust data does not have a field that is required in …\nThe Rust value is out of range supported by the CQL type.\nOne of the values in the map failed to serialize.\nThe tuple has the wrong element count.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe CQL type that the Rust type was being serialized to.\nThe CQL type that the Rust type was being serialized to.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDetailed information about the failure.\nDetailed information about the failure.\nName of the Rust type being serialized.\nName of the Rust type being serialized.\nSerializes the value to given CQL type.\nThe list of types that the Rust type can serialize as.\nThe error that caused the tuple field serialization to …\nIndex of the tuple element that failed to serialize.\nThe number of elements that the CQL tuple type has.\nThe number of elements that the Rust tuple has.\nThe error that caused the UDT field serialization to fail.\nName of the field which failed to serialize.\nThe name of the CQL UDT field.\nName of field that the CQL UDT requires but is missing in …\nName of the Rust struct field that is missing in the UDT.\nKeyspace in which the UDT was defined.\nThe name of the Rust field.\nName of the UDT.\nThere was an attempt to produce a CQL value over the …\nAllows appending bytes to a non-null, non-unset cell.\nRepresents a handle to a CQL value that needs to be …\nAn interface that facilitates writing values for a CQL …\nAn object that indicates a type-level proof that something …\nAppends raw bytes to this cell.\nAppends the values from an existing <code>SerializedValues</code> …\nFinishes serializing the value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTurns this writter into a <code>CellValueBuilder</code> which can be …\nAppends a new value to the sequence and returns an object …\nAppends a sub-value to the end of the current contents of …\nCreates a new row writer based on an existing Vec.\nCreates a new cell writer based on an existing Vec.\nSets this value to be null, consuming this object.\nSets this value to represent an unset value, consuming …\nSets this value to a non-zero, non-unset value with given …\nReturns the number of values that were written so far.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCQL batch statement.\nThis enum represents a CQL statement, that can be part of …\nThe type of a batch.\nAppends a new statement to the batch.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the consistency to be used when executing this batch …\nBorrows the execution profile handle associated with this …\nGets the idempotence of this batch\nGet the retry policy set for the batch.\nGets the serial consistency to be used when executing this …\nGets the default timestamp for this batch in microseconds.\nGets whether tracing is enabled for this batch\nGets type of batch.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new, empty <code>Batch</code> of <code>batch_type</code> type.\nCreates a new, empty <code>Batch</code> of <code>batch_type</code> type with the …\nRemoves the listener set by <code>set_history_listener</code>.\nSets the consistency to be used when executing this batch.\nAssociates the batch with execution profile referred by …\nSets the listener capable of listening what happens during …\nSets the idempotence of this batch A query is idempotent …\nSet the retry policy for this batch, overriding the one …\nSets the serial consistency to be used when executing this …\nSets the default timestamp for this batch in microseconds. …\nEnable or disable CQL Tracing for this batch If enabled …\nAn error returned by …\nFailed to extract partition key.\nRepresents a statement prepared on the server.\nFailed to serialize values required to compute partition …\nFailed to calculate token.\nCalculates the token for given prepared statement and …\nComputes the partition key of the target table from given …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the consistency to be used when executing this …\nBorrows the execution profile handle associated with this …\nGets the idempotence of this statement\nReturns the name of the keyspace this statement is …\nReturns the page size for this CQL query.\nGet the name of the partitioner used for this statement.\nGets tracing ids of queries used to prepare this statement\nGets client timeout associated with this query\nAccess column specifications of the result set returned …\nGet the retry policy set for the statement.\nGets the serial consistency to be used when executing this …\nReturns the name of the table this statement is operating …\nReturn keyspace name and table name this statement is …\nGets the default timestamp for this statement in …\nGets whether tracing is enabled for this statement\nGets the information whether the driver uses cached …\nAccess column specifications of the bind variables of this …\nAccess info about partition key indexes of the bind …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the error to <code>ExecutionError</code>.\nReturns true if it is known that the prepared statement …\nReturns true if the prepared statement has necessary …\nRemoves the listener set by <code>set_history_listener</code>.\nSets the consistency to be used when executing this …\nAssociates the query with execution profile referred by …\nSets the listener capable of listening what happens during …\nSets the idempotence of this statement A query is …\nSets the page size for this CQL query.\nSets the client-side timeout for this statement. If not …\nSet the retry policy for this statement, overriding the …\nSets the serial consistency to be used when executing this …\nSets the default timestamp for this statement in …\nEnable or disable CQL Tracing for this statement If …\nMake use of cached metadata to decode results of the …\n<strong>Unprepared</strong> CQL statement.\nReturns the argument unchanged.\nGets the consistency to be used when executing this …\nBorrows the execution profile handle associated with this …\nGets the idempotence of this statement\nReturns the page size for this CQL statement.\nGets client timeout associated with this statement.\nGet the retry policy set for the statement.\nGets the serial consistency to be used when executing this …\nGets the default timestamp for this statement in …\nGets whether tracing is enabled for this statement\nCalls <code>U::from(self)</code>.\nCreates a new <code>Statement</code> from a CQL statement string.\nRemoves the listener set by <code>set_history_listener</code>.\nSets the consistency to be used when executing this …\nAssociates the query with execution profile referred by …\nSets the listener capable of listening what happens during …\nSets the idempotence of this statement A statement is …\nSets the page size for this CQL statement.\nSets the client-side timeout for this statement. If not …\nSet the retry policy for this statement, overriding the …\nSets the serial consistency to be used when executing this …\nSets the default timestamp for this statement in …\nEnable or disable CQL Tracing for this statement If …\nReturns self with page size set to the given value.\nRepresents an counter value\nNative CQL date representation that allows for a bigger …\nNative CQL <code>decimal</code> representation.\nBorrowed version of native CQL <code>decimal</code> representation.\nRepresents a CQL Duration value\nNative CQL time representation.\nNative CQL timestamp representation that allows full …\nRepresents timeuuid (uuid V1) value\nNative CQL <code>varint</code> representation.\nA borrowed version of native CQL <code>varint</code> representation.\nDays since -5877641-06-23 i.e. 2^31 days before unix epoch …\nEnum providing a way to represent a value that might be …\nNanoseconds since midnight\nMilliseconds since unix epoch\nRepresents an unset value\nReturns a slice of bytes in two’s complement binary …\nReturns a slice of bytes in two’s complement binary …\nReturns a slice of bytes in two’s complement binary …\nReturns a slice of bytes in two’s complement binary …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a <code>CqlDecimal</code> from an array of bytes representing …\nCreates a <code>CqlDecimal</code> from a slice of bytes representing …\nCreates a <code>CqlDecimalBorrowed</code> from a slice of bytes …\nCreates a <code>CqlVarint</code> from an array of bytes in two’s …\nCreates a <code>CqlVarint</code> from a slice of bytes in two’s …\nCreates a <code>CqlVarintBorrowed</code> from a slice of bytes in two’…\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts <code>CqlDecimal</code> to an array of bytes in two’s …\nConverts <code>CqlVarint</code> to an array of bytes in two’s …\nOrder of <code>fields</code> vector must match the order of fields as …")